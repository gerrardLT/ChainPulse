# 数据库设计文档

## 项目名称：ChainPulse - 实时链上事件通知与可视化系统

---

## 1. 数据库概览

### 1.1 数据库选型

- **主数据库**：PostgreSQL 15+（通过 Supabase 托管）
- **缓存数据库**：Redis 7+
- **索引器数据库**：PostgreSQL（Envio 专用）

### 1.2 设计原则

- **规范化**：符合第三范式，避免数据冗余
- **索引优化**：为高频查询字段建立索引
- **数据完整性**：使用外键约束和检查约束
- **扩展性**：预留扩展字段，支持 JSONB 存储灵活数据
- **审计追踪**：关键表包含创建时间和更新时间

---

## 2. 数据库架构图

```
┌─────────────────────────────────────────────────────────────┐
│                     应用数据库 (PostgreSQL)                   │
├─────────────────────────────────────────────────────────────┤
│                                                             │
│  ┌──────────┐    ┌──────────┐    ┌──────────┐             │
│  │  users   │────│ accounts │────│  rules   │             │
│  └──────────┘    └──────────┘    └──────────┘             │
│       │               │                                     │
│       │          ┌────┴────┐                               │
│       │          │         │                               │
│  ┌────┴────┐    ┌─────────┴─────┐    ┌──────────┐        │
│  │ notif   │    │ subscriptions │    │  events  │        │
│  │ settings│    └───────────────┘    └──────────┘        │
│  └─────────┘                                               │
│       │                                                     │
│  ┌────┴────────┐    ┌──────────────┐                      │
│  │ telegram    │    │   discord    │                      │
│  │  configs    │    │   configs    │                      │
│  └─────────────┘    └──────────────┘                      │
│                                                             │
└─────────────────────────────────────────────────────────────┘

┌─────────────────────────────────────────────────────────────┐
│                  索引器数据库 (Envio PostgreSQL)             │
├─────────────────────────────────────────────────────────────┤
│                                                             │
│  ┌─────────────┐    ┌─────────────┐    ┌─────────────┐   │
│  │  raw_events │────│   entities  │────│   blocks    │   │
│  └─────────────┘    └─────────────┘    └─────────────┘   │
│                                                             │
└─────────────────────────────────────────────────────────────┘

┌─────────────────────────────────────────────────────────────┐
│                       缓存层 (Redis)                         │
├─────────────────────────────────────────────────────────────┤
│  • 用户会话 (sessions:*)                                     │
│  • 实时事件缓存 (events:recent:*)                            │
│  • 统计数据缓存 (stats:*)                                    │
│  • WebSocket 连接映射 (ws:connections:*)                    │
└─────────────────────────────────────────────────────────────┘
```

---

## 3. 核心数据表设计

### 3.1 用户表 (users)

存储用户基本信息和认证数据。

```sql
CREATE TABLE users (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  wallet_address VARCHAR(42) NOT NULL UNIQUE,
  ens_name VARCHAR(255),
  email VARCHAR(255),
  avatar_url TEXT,
  is_active BOOLEAN DEFAULT true,
  last_login_at TIMESTAMP WITH TIME ZONE,
  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
  updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
  
  CONSTRAINT wallet_address_format CHECK (wallet_address ~* '^0x[a-fA-F0-9]{40}$')
);

-- 索引
CREATE INDEX idx_users_wallet_address ON users(wallet_address);
CREATE INDEX idx_users_created_at ON users(created_at DESC);
CREATE INDEX idx_users_last_login_at ON users(last_login_at DESC);

-- 触发器：自动更新 updated_at
CREATE TRIGGER update_users_updated_at
  BEFORE UPDATE ON users
  FOR EACH ROW
  EXECUTE FUNCTION update_updated_at_column();
```

**字段说明**：

| 字段 | 类型 | 说明 |
|------|------|------|
| id | UUID | 用户唯一标识符 |
| wallet_address | VARCHAR(42) | 钱包地址（0x开头） |
| ens_name | VARCHAR(255) | ENS 域名（可选） |
| email | VARCHAR(255) | 邮箱地址（可选，用于通知） |
| avatar_url | TEXT | 头像 URL |
| is_active | BOOLEAN | 账户是否激活 |
| last_login_at | TIMESTAMP | 最后登录时间 |
| created_at | TIMESTAMP | 创建时间 |
| updated_at | TIMESTAMP | 更新时间 |

---

### 3.2 智能账户表 (smart_accounts)

存储用户的智能账户信息。

```sql
CREATE TABLE smart_accounts (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE,
  account_address VARCHAR(42) NOT NULL UNIQUE,
  owner_address VARCHAR(42) NOT NULL,
  account_type VARCHAR(50) DEFAULT 'erc4337',
  chain_id INTEGER NOT NULL DEFAULT 1,
  is_deployed BOOLEAN DEFAULT false,
  deployment_tx_hash VARCHAR(66),
  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
  updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
  
  CONSTRAINT account_address_format CHECK (account_address ~* '^0x[a-fA-F0-9]{40}$'),
  CONSTRAINT owner_address_format CHECK (owner_address ~* '^0x[a-fA-F0-9]{40}$'),
  CONSTRAINT deployment_tx_format CHECK (deployment_tx_hash IS NULL OR deployment_tx_hash ~* '^0x[a-fA-F0-9]{64}$')
);

-- 索引
CREATE INDEX idx_smart_accounts_user_id ON smart_accounts(user_id);
CREATE INDEX idx_smart_accounts_account_address ON smart_accounts(account_address);
CREATE INDEX idx_smart_accounts_owner_address ON smart_accounts(owner_address);
CREATE INDEX idx_smart_accounts_chain_id ON smart_accounts(chain_id);
```

**字段说明**：

| 字段 | 类型 | 说明 |
|------|------|------|
| id | UUID | 记录唯一标识符 |
| user_id | UUID | 关联的用户 ID |
| account_address | VARCHAR(42) | 智能账户地址 |
| owner_address | VARCHAR(42) | 所有者 EOA 地址 |
| account_type | VARCHAR(50) | 账户类型（erc4337） |
| chain_id | INTEGER | 链 ID（1=以太坊主网） |
| is_deployed | BOOLEAN | 是否已部署 |
| deployment_tx_hash | VARCHAR(66) | 部署交易哈希 |
| created_at | TIMESTAMP | 创建时间 |
| updated_at | TIMESTAMP | 更新时间 |

---

### 3.3 事件订阅表 (event_subscriptions)

存储用户订阅的事件类型。

```sql
CREATE TABLE event_subscriptions (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE,
  event_type VARCHAR(100) NOT NULL,
  contract_address VARCHAR(42),
  chain_id INTEGER NOT NULL DEFAULT 1,
  is_enabled BOOLEAN DEFAULT true,
  notification_channels JSONB DEFAULT '{"browser": true, "telegram": false, "discord": false}'::jsonb,
  filter_conditions JSONB,
  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
  updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
  
  CONSTRAINT unique_user_event CHECK (user_id IS NOT NULL),
  UNIQUE(user_id, event_type, contract_address, chain_id)
);

-- 索引
CREATE INDEX idx_subscriptions_user_id ON event_subscriptions(user_id);
CREATE INDEX idx_subscriptions_event_type ON event_subscriptions(event_type);
CREATE INDEX idx_subscriptions_is_enabled ON event_subscriptions(is_enabled) WHERE is_enabled = true;
CREATE INDEX idx_subscriptions_channels ON event_subscriptions USING GIN(notification_channels);
```

**字段说明**：

| 字段 | 类型 | 说明 |
|------|------|------|
| id | UUID | 订阅记录唯一标识符 |
| user_id | UUID | 用户 ID |
| event_type | VARCHAR(100) | 事件类型（如 Transfer, Stake） |
| contract_address | VARCHAR(42) | 合约地址（可选，监听特定合约） |
| chain_id | INTEGER | 链 ID |
| is_enabled | BOOLEAN | 是否启用该订阅 |
| notification_channels | JSONB | 通知渠道配置 |
| filter_conditions | JSONB | 过滤条件（如金额范围） |
| created_at | TIMESTAMP | 创建时间 |
| updated_at | TIMESTAMP | 更新时间 |

---

### 3.4 通知记录表 (notifications)

存储发送给用户的通知记录。

```sql
CREATE TABLE notifications (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE,
  event_id VARCHAR(66) NOT NULL,
  event_type VARCHAR(100) NOT NULL,
  title VARCHAR(255) NOT NULL,
  content TEXT NOT NULL,
  metadata JSONB,
  is_read BOOLEAN DEFAULT false,
  read_at TIMESTAMP WITH TIME ZONE,
  priority VARCHAR(20) DEFAULT 'normal',
  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
  
  CONSTRAINT priority_check CHECK (priority IN ('low', 'normal', 'high', 'urgent'))
);

-- 索引
CREATE INDEX idx_notifications_user_id ON notifications(user_id);
CREATE INDEX idx_notifications_is_read ON notifications(is_read) WHERE is_read = false;
CREATE INDEX idx_notifications_created_at ON notifications(created_at DESC);
CREATE INDEX idx_notifications_event_type ON notifications(event_type);
CREATE INDEX idx_notifications_priority ON notifications(priority);

-- 分区（按月）
-- 注意：schema.sql 中已预创建 3 个月的分区（当前月及未来2个月）
-- 生产环境需要定期创建新分区，建议使用 pg_cron 自动化
CREATE TABLE notifications_2025_10 PARTITION OF notifications
  FOR VALUES FROM ('2025-10-01') TO ('2025-11-01');

CREATE TABLE notifications_2025_11 PARTITION OF notifications
  FOR VALUES FROM ('2025-11-01') TO ('2025-12-01');

CREATE TABLE notifications_2025_12 PARTITION OF notifications
  FOR VALUES FROM ('2025-12-01') TO ('2026-01-01');
```

**分区策略**：
- **分区类型**：按时间范围分区（RANGE）
- **分区间隔**：每月一个分区
- **预创建周期**：当前月 + 未来 2 个月
- **管理方式**：
  - 手动创建：每月初创建下3个月的分区
  - 自动创建：使用 pg_cron 定时任务（推荐）
  - 归档策略：旧分区可以 DETACH 后归档或删除

**自动创建分区示例**：
```sql
-- 使用 pg_cron 每月1号自动创建下3个月的分区
SELECT cron.schedule('create-next-partitions', '0 0 1 * *', 
  $$
  -- 创建通知分区的逻辑
  -- 需要根据当前日期动态生成分区表名
  $$);
```

**字段说明**：

| 字段 | 类型 | 说明 |
|------|------|------|
| id | UUID | 通知唯一标识符 |
| user_id | UUID | 接收通知的用户 ID |
| event_id | VARCHAR(66) | 关联的事件 ID（交易哈希） |
| event_type | VARCHAR(100) | 事件类型 |
| title | VARCHAR(255) | 通知标题 |
| content | TEXT | 通知内容 |
| metadata | JSONB | 额外元数据（金额、地址等） |
| is_read | BOOLEAN | 是否已读 |
| read_at | TIMESTAMP | 已读时间 |
| priority | VARCHAR(20) | 优先级 |
| created_at | TIMESTAMP | 创建时间 |

---

### 3.5 自动化规则表 (automation_rules)

存储智能账户的自动化执行规则。

```sql
CREATE TABLE automation_rules (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE,
  smart_account_id UUID NOT NULL REFERENCES smart_accounts(id) ON DELETE CASCADE,
  rule_name VARCHAR(255) NOT NULL,
  description TEXT,
  trigger_event VARCHAR(100) NOT NULL,
  trigger_conditions JSONB NOT NULL,
  action_type VARCHAR(100) NOT NULL,
  action_params JSONB NOT NULL,
  is_enabled BOOLEAN DEFAULT true,
  execution_count INTEGER DEFAULT 0,
  last_executed_at TIMESTAMP WITH TIME ZONE,
  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
  updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- 索引
CREATE INDEX idx_automation_rules_user_id ON automation_rules(user_id);
CREATE INDEX idx_automation_rules_smart_account_id ON automation_rules(smart_account_id);
CREATE INDEX idx_automation_rules_is_enabled ON automation_rules(is_enabled) WHERE is_enabled = true;
CREATE INDEX idx_automation_rules_trigger_event ON automation_rules(trigger_event);
```

**字段说明**：

| 字段 | 类型 | 说明 |
|------|------|------|
| id | UUID | 规则唯一标识符 |
| user_id | UUID | 用户 ID |
| smart_account_id | UUID | 智能账户 ID |
| rule_name | VARCHAR(255) | 规则名称 |
| description | TEXT | 规则描述 |
| trigger_event | VARCHAR(100) | 触发事件类型 |
| trigger_conditions | JSONB | 触发条件（如金额阈值） |
| action_type | VARCHAR(100) | 执行操作类型（transfer, stake） |
| action_params | JSONB | 操作参数 |
| is_enabled | BOOLEAN | 是否启用 |
| execution_count | INTEGER | 执行次数统计 |
| last_executed_at | TIMESTAMP | 最后执行时间 |
| created_at | TIMESTAMP | 创建时间 |
| updated_at | TIMESTAMP | 更新时间 |

**示例数据**：
```json
{
  "rule_name": "Auto Stake Large Deposits",
  "trigger_event": "Transfer",
  "trigger_conditions": {
    "minAmount": "10000000000000000000",
    "token": "ETH"
  },
  "action_type": "stake",
  "action_params": {
    "protocol": "lido",
    "percentage": 50
  }
}
```

---

### 3.6 Telegram 配置表 (telegram_configs)

存储用户的 Telegram 绑定信息。

```sql
CREATE TABLE telegram_configs (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id UUID NOT NULL UNIQUE REFERENCES users(id) ON DELETE CASCADE,
  chat_id BIGINT NOT NULL UNIQUE,
  username VARCHAR(255),
  binding_code VARCHAR(10),
  is_verified BOOLEAN DEFAULT false,
  verified_at TIMESTAMP WITH TIME ZONE,
  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
  updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- 索引
CREATE INDEX idx_telegram_configs_user_id ON telegram_configs(user_id);
CREATE INDEX idx_telegram_configs_chat_id ON telegram_configs(chat_id);
CREATE INDEX idx_telegram_configs_binding_code ON telegram_configs(binding_code) WHERE binding_code IS NOT NULL;
```

**字段说明**：

| 字段 | 类型 | 说明 |
|------|------|------|
| id | UUID | 记录唯一标识符 |
| user_id | UUID | 用户 ID |
| chat_id | BIGINT | Telegram Chat ID |
| username | VARCHAR(255) | Telegram 用户名 |
| binding_code | VARCHAR(10) | 绑定验证码 |
| is_verified | BOOLEAN | 是否已验证 |
| verified_at | TIMESTAMP | 验证时间 |
| created_at | TIMESTAMP | 创建时间 |
| updated_at | TIMESTAMP | 更新时间 |

---

### 3.7 Discord 配置表 (discord_configs)

存储用户的 Discord Webhook 配置。

```sql
CREATE TABLE discord_configs (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id UUID NOT NULL UNIQUE REFERENCES users(id) ON DELETE CASCADE,
  webhook_url TEXT NOT NULL,
  webhook_name VARCHAR(255),
  is_verified BOOLEAN DEFAULT false,
  verified_at TIMESTAMP WITH TIME ZONE,
  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
  updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
  
  CONSTRAINT webhook_url_format CHECK (webhook_url LIKE 'https://discord.com/api/webhooks/%')
);

-- 索引
CREATE INDEX idx_discord_configs_user_id ON discord_configs(user_id);
```

**字段说明**：

| 字段 | 类型 | 说明 |
|------|------|------|
| id | UUID | 记录唯一标识符 |
| user_id | UUID | 用户 ID |
| webhook_url | TEXT | Discord Webhook URL |
| webhook_name | VARCHAR(255) | Webhook 名称 |
| is_verified | BOOLEAN | 是否已验证 |
| verified_at | TIMESTAMP | 验证时间 |
| created_at | TIMESTAMP | 创建时间 |
| updated_at | TIMESTAMP | 更新时间 |

---

### 3.8 事件缓存表 (events_cache)

用于快速查询和统计的事件缓存表（从 Envio 同步）。

```sql
CREATE TABLE events_cache (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  tx_hash VARCHAR(66) NOT NULL,
  block_number BIGINT NOT NULL,
  block_timestamp TIMESTAMP WITH TIME ZONE NOT NULL,
  chain_id INTEGER NOT NULL,
  contract_address VARCHAR(42) NOT NULL,
  event_type VARCHAR(100) NOT NULL,
  from_address VARCHAR(42),
  to_address VARCHAR(42),
  amount NUMERIC(78, 0),
  token_address VARCHAR(42),
  gas_used BIGINT,
  gas_price BIGINT,
  status VARCHAR(20) DEFAULT 'success',
  raw_data JSONB,
  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
  
  CONSTRAINT tx_hash_format CHECK (tx_hash ~* '^0x[a-fA-F0-9]{64}$'),
  CONSTRAINT status_check CHECK (status IN ('success', 'failed', 'pending'))
);

-- 索引
CREATE INDEX idx_events_cache_tx_hash ON events_cache(tx_hash);
CREATE INDEX idx_events_cache_block_number ON events_cache(block_number DESC);
CREATE INDEX idx_events_cache_block_timestamp ON events_cache(block_timestamp DESC);
CREATE INDEX idx_events_cache_chain_id ON events_cache(chain_id);
CREATE INDEX idx_events_cache_event_type ON events_cache(event_type);
CREATE INDEX idx_events_cache_from_address ON events_cache(from_address);
CREATE INDEX idx_events_cache_to_address ON events_cache(to_address);
CREATE INDEX idx_events_cache_contract_address ON events_cache(contract_address);

-- 分区（按月）
-- 注意：schema.sql 中已预创建 3 个月的分区
CREATE TABLE events_cache_2025_10 PARTITION OF events_cache
  FOR VALUES FROM ('2025-10-01') TO ('2025-11-01');

CREATE TABLE events_cache_2025_11 PARTITION OF events_cache
  FOR VALUES FROM ('2025-11-01') TO ('2025-12-01');

CREATE TABLE events_cache_2025_12 PARTITION OF events_cache
  FOR VALUES FROM ('2025-12-01') TO ('2026-01-01');
```

**分区策略**：与 notifications 表相同，按月分区。

**字段说明**：

| 字段 | 类型 | 说明 |
|------|------|------|
| id | UUID | 记录唯一标识符 |
| tx_hash | VARCHAR(66) | 交易哈希 |
| block_number | BIGINT | 区块号 |
| block_timestamp | TIMESTAMP | 区块时间戳 |
| chain_id | INTEGER | 链 ID |
| contract_address | VARCHAR(42) | 合约地址 |
| event_type | VARCHAR(100) | 事件类型 |
| from_address | VARCHAR(42) | 发送方地址 |
| to_address | VARCHAR(42) | 接收方地址 |
| amount | NUMERIC(78, 0) | 金额（Wei） |
| token_address | VARCHAR(42) | 代币合约地址 |
| gas_used | BIGINT | Gas 使用量 |
| gas_price | BIGINT | Gas 价格 |
| status | VARCHAR(20) | 交易状态 |
| raw_data | JSONB | 原始事件数据 |
| created_at | TIMESTAMP | 创建时间 |

---

## 4. 辅助表

### 4.1 用户会话表 (user_sessions)

存储用户登录会话信息。

```sql
CREATE TABLE user_sessions (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE,
  token_hash VARCHAR(64) NOT NULL UNIQUE,
  ip_address INET,
  user_agent TEXT,
  expires_at TIMESTAMP WITH TIME ZONE NOT NULL,
  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- 索引
CREATE INDEX idx_user_sessions_user_id ON user_sessions(user_id);
CREATE INDEX idx_user_sessions_token_hash ON user_sessions(token_hash);
CREATE INDEX idx_user_sessions_expires_at ON user_sessions(expires_at);

-- 自动清理过期会话
CREATE INDEX idx_user_sessions_expired ON user_sessions(expires_at) WHERE expires_at < NOW();
```

---

### 4.2 审计日志表 (audit_logs)

记录关键操作的审计日志。

```sql
CREATE TABLE audit_logs (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id UUID REFERENCES users(id) ON DELETE SET NULL,
  action VARCHAR(100) NOT NULL,
  resource_type VARCHAR(100) NOT NULL,
  resource_id UUID,
  details JSONB,
  ip_address INET,
  user_agent TEXT,
  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- 索引
CREATE INDEX idx_audit_logs_user_id ON audit_logs(user_id);
CREATE INDEX idx_audit_logs_action ON audit_logs(action);
CREATE INDEX idx_audit_logs_resource_type ON audit_logs(resource_type);
CREATE INDEX idx_audit_logs_created_at ON audit_logs(created_at DESC);

-- 分区（按月）
CREATE TABLE audit_logs_2025_10 PARTITION OF audit_logs
  FOR VALUES FROM ('2025-10-01') TO ('2025-11-01');
```

---

## 5. 视图（Views）

### 5.1 用户统计视图

```sql
CREATE VIEW user_stats AS
SELECT 
  u.id AS user_id,
  u.wallet_address,
  COUNT(DISTINCT sa.id) AS smart_accounts_count,
  COUNT(DISTINCT es.id) AS subscriptions_count,
  COUNT(n.id) AS total_notifications,
  COUNT(n.id) FILTER (WHERE n.is_read = false) AS unread_notifications,
  COUNT(ar.id) AS automation_rules_count,
  u.created_at,
  u.last_login_at
FROM users u
LEFT JOIN smart_accounts sa ON u.id = sa.user_id
LEFT JOIN event_subscriptions es ON u.id = es.user_id AND es.is_enabled = true
LEFT JOIN notifications n ON u.id = n.user_id
LEFT JOIN automation_rules ar ON u.id = ar.user_id AND ar.is_enabled = true
GROUP BY u.id;
```

### 5.2 事件统计视图

```sql
CREATE VIEW event_stats AS
SELECT 
  DATE_TRUNC('hour', block_timestamp) AS hour,
  chain_id,
  event_type,
  COUNT(*) AS event_count,
  COUNT(DISTINCT from_address) AS unique_senders,
  COUNT(DISTINCT to_address) AS unique_receivers,
  SUM(gas_used) AS total_gas_used,
  AVG(gas_price) AS avg_gas_price
FROM events_cache
WHERE block_timestamp >= NOW() - INTERVAL '7 days'
GROUP BY DATE_TRUNC('hour', block_timestamp), chain_id, event_type;
```

---

## 6. Redis 缓存设计

### 6.1 缓存键命名规范

| 用途 | 键格式 | 过期时间 | 示例 |
|------|--------|---------|------|
| 用户会话 | `session:{token}` | 7天 | `session:abc123...` |
| 用户信息 | `user:{userId}` | 1小时 | `user:550e8400-e29b-41d4-a716-446655440000` |
| 实时事件 | `events:recent:{userId}` | 5分钟 | `events:recent:550e...` |
| 通知统计 | `stats:notifications:{userId}` | 10分钟 | `stats:notifications:550e...` |
| WebSocket连接 | `ws:connection:{userId}` | 无限期 | `ws:connection:550e...` |
| 事件计数 | `stats:events:24h:{chainId}` | 1小时 | `stats:events:24h:1` |

### 6.2 缓存数据结构

**用户会话（String）**：
```redis
SET session:abc123 "userId:550e8400-e29b-41d4-a716-446655440000" EX 604800
```

**实时事件列表（List）**：
```redis
LPUSH events:recent:550e... "{\"type\":\"Transfer\",\"amount\":\"100\"}"
LTRIM events:recent:550e... 0 99  # 只保留最近100条
EXPIRE events:recent:550e... 300
```

**通知统计（Hash）**：
```redis
HSET stats:notifications:550e... total 156 unread 12
EXPIRE stats:notifications:550e... 600
```

**WebSocket 连接映射（String）**：
```redis
SET ws:connection:550e... "socketId:abc123"
```

---

## 7. 数据库函数和触发器

### 7.1 自动更新时间戳函数

```sql
CREATE OR REPLACE FUNCTION update_updated_at_column()
RETURNS TRIGGER AS $$
BEGIN
  NEW.updated_at = NOW();
  RETURN NEW;
END;
$$ LANGUAGE plpgsql;
```

### 7.2 通知标记已读触发器

```sql
CREATE OR REPLACE FUNCTION set_notification_read_at()
RETURNS TRIGGER AS $$
BEGIN
  IF NEW.is_read = true AND OLD.is_read = false THEN
    NEW.read_at = NOW();
  END IF;
  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER trigger_notification_read
  BEFORE UPDATE ON notifications
  FOR EACH ROW
  EXECUTE FUNCTION set_notification_read_at();
```

### 7.3 自动化规则执行计数触发器

```sql
CREATE OR REPLACE FUNCTION increment_rule_execution()
RETURNS TRIGGER AS $$
BEGIN
  UPDATE automation_rules
  SET 
    execution_count = execution_count + 1,
    last_executed_at = NOW()
  WHERE id = NEW.rule_id;
  RETURN NEW;
END;
$$ LANGUAGE plpgsql;
```

---

## 8. 数据库安全策略

### 8.1 行级安全策略（RLS）

为 Supabase 配置行级安全策略：

```sql
-- 启用 RLS
ALTER TABLE users ENABLE ROW LEVEL SECURITY;
ALTER TABLE notifications ENABLE ROW LEVEL SECURITY;
ALTER TABLE event_subscriptions ENABLE ROW LEVEL SECURITY;

-- 用户只能访问自己的数据
CREATE POLICY "Users can view own data" ON users
  FOR SELECT
  USING (auth.uid() = id);

CREATE POLICY "Users can view own notifications" ON notifications
  FOR SELECT
  USING (auth.uid() = user_id);

CREATE POLICY "Users can update own notifications" ON notifications
  FOR UPDATE
  USING (auth.uid() = user_id);
```

### 8.2 敏感数据加密

- Webhook URL 在存储前加密
- 使用 PostgreSQL `pgcrypto` 扩展
- 敏感字段使用 AES-256 加密

```sql
CREATE EXTENSION IF NOT EXISTS pgcrypto;

-- 加密 Webhook URL
UPDATE discord_configs
SET webhook_url = pgp_sym_encrypt(webhook_url, 'encryption_key');
```

---

## 9. 数据备份与恢复

### 9.1 备份策略

- **自动备份**：每天凌晨 2:00 UTC 全量备份
- **增量备份**：每 6 小时一次
- **保留期限**：30 天
- **备份位置**：AWS S3 / Supabase 自动备份

### 9.2 恢复流程

```sql
-- 恢复到特定时间点
pg_restore --dbname=chainpulse --clean --if-exists backup_file.dump

-- 恢复特定表
pg_restore --dbname=chainpulse --table=users backup_file.dump
```

---

## 10. 数据迁移脚本

### 10.1 初始化数据库

```sql
-- 创建扩展
CREATE EXTENSION IF NOT EXISTS "uuid-ossp";
CREATE EXTENSION IF NOT EXISTS "pgcrypto";

-- 创建所有表（按依赖顺序）
-- 1. users
-- 2. smart_accounts
-- 3. event_subscriptions
-- 4. notifications
-- 5. automation_rules
-- 6. telegram_configs
-- 7. discord_configs
-- 8. events_cache
-- 9. user_sessions
-- 10. audit_logs
```

### 10.2 种子数据

种子数据包括：
- 测试用户账户
- 智能账户示例
- 事件订阅配置
- 通知记录
- 自动化规则
- 第三方集成配置
- 事件缓存数据

详见 `database/seed.sql` 文件。

---

## 11. 性能优化

### 11.1 索引策略

- 为所有外键字段创建索引
- 为高频查询字段创建复合索引
- 使用部分索引优化特定查询

```sql
-- 复合索引示例
CREATE INDEX idx_events_cache_timestamp_type ON events_cache(block_timestamp DESC, event_type);

-- 部分索引示例
CREATE INDEX idx_notifications_unread ON notifications(user_id, created_at DESC) 
  WHERE is_read = false;
```

### 11.2 查询优化

- 使用 `EXPLAIN ANALYZE` 分析查询性能
- 避免 N+1 查询问题
- 使用物化视图缓存复杂聚合查询

```sql
-- 物化视图示例
CREATE MATERIALIZED VIEW daily_event_summary AS
SELECT 
  DATE(block_timestamp) AS date,
  chain_id,
  event_type,
  COUNT(*) AS count,
  SUM(gas_used) AS total_gas
FROM events_cache
GROUP BY DATE(block_timestamp), chain_id, event_type;

-- 刷新物化视图
REFRESH MATERIALIZED VIEW CONCURRENTLY daily_event_summary;
```

### 11.3 表分区

对大表进行分区以提高查询性能：

```sql
-- 按时间范围分区
CREATE TABLE notifications (
  -- columns...
) PARTITION BY RANGE (created_at);

-- 创建分区表
CREATE TABLE notifications_2025_10 PARTITION OF notifications
  FOR VALUES FROM ('2025-10-01') TO ('2025-11-01');
```

---

## 12. 监控指标

### 12.1 数据库监控

- 活跃连接数
- 查询执行时间（慢查询 > 1秒）
- 表大小和增长率
- 索引使用率
- 缓存命中率

### 12.2 关键查询示例

**查询慢查询**：
```sql
SELECT 
  query,
  calls,
  total_time,
  mean_time,
  max_time
FROM pg_stat_statements
WHERE mean_time > 1000
ORDER BY total_time DESC
LIMIT 20;
```

**查询表大小**：
```sql
SELECT 
  schemaname,
  tablename,
  pg_size_pretty(pg_total_relation_size(schemaname||'.'||tablename)) AS size
FROM pg_tables
WHERE schemaname = 'public'
ORDER BY pg_total_relation_size(schemaname||'.'||tablename) DESC;
```

---

## 13. 数据保留策略

### 13.1 自动清理

```sql
-- 清理30天前的通知
DELETE FROM notifications
WHERE created_at < NOW() - INTERVAL '30 days' AND is_read = true;

-- 清理过期会话
DELETE FROM user_sessions
WHERE expires_at < NOW();

-- 归档90天前的事件缓存
INSERT INTO events_cache_archive
SELECT * FROM events_cache
WHERE block_timestamp < NOW() - INTERVAL '90 days';

DELETE FROM events_cache
WHERE block_timestamp < NOW() - INTERVAL '90 days';
```

### 13.2 定时任务

使用 `pg_cron` 扩展设置定时清理任务：

```sql
CREATE EXTENSION IF NOT EXISTS pg_cron;

-- 每天凌晨3点清理过期数据
SELECT cron.schedule('cleanup-old-notifications', '0 3 * * *', 
  'DELETE FROM notifications WHERE created_at < NOW() - INTERVAL ''30 days'' AND is_read = true');
```

---

## 14. ER 图

```
┌─────────────┐          ┌─────────────────┐
│    users    │──────────│ smart_accounts  │
└─────────────┘ 1      * └─────────────────┘
       │                          │
       │ 1                        │ 1
       │                          │
       │ *                        │ *
┌──────┴────────┐          ┌─────┴─────────┐
│ event_        │          │ automation_   │
│ subscriptions │          │ rules         │
└───────────────┘          └───────────────┘
       │
       │ 1
       │
       │ *
┌──────┴────────┐
│ notifications │
└───────────────┘

┌─────────────┐          ┌─────────────────┐
│    users    │──────────│ telegram_       │
└─────────────┘ 1      1 │ configs         │
       │                 └─────────────────┘
       │ 1
       │
       │ 1
┌──────┴────────┐
│ discord_      │
│ configs       │
└───────────────┘
```

---

## 15. 总结

本数据库设计包含：

- ✅ 8 个核心业务表
- ✅ 4 个辅助表
- ✅ 完整的索引策略
- ✅ 行级安全策略
- ✅ 数据分区方案
- ✅ Redis 缓存设计
- ✅ 触发器和函数
- ✅ 备份和恢复策略
- ✅ 性能优化方案
- ✅ 数据保留政策

设计遵循最佳实践，支持高并发、实时查询和数据安全需求。

